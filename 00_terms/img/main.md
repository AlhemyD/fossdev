# Терминология

В данном курсе мы будем использовать терминологию, связанную с разработкой программного обеспечения, поэтому полезно собрать все термины в одном месте. Ниже мы будем приводить русский и английский вариант терминов, так как последнее будет полезно при поиске информации. 


### Парадигма программирования (англ. - programming paradigm)

Способ, как мы смотрим на то, что происходит при разработке. Например с точки зрения водителя улица, через которую он едет *транзитом*, это ширина проезжей части дороги, количество светофоров и прочее. Но улица, на которой расположен пункт назначения, уже рассматривается водителем с точки зрения удобности парковки, хотя на транзитной улице тоже есть парковочные места. Т.е. на одну и ту же сущность *улицу* мы можем смотреть под разными углами, с точки зрения того, что сейчас для нас важно. *Парадигма программирования* — это способ описать задачу, например, данные и действия над ними. Рассмотрим процедурную и объектно-ориентированную парадигмы. **Процедурное** программирование описывает список действий (процедур), которые мы предпринимаем для достижения цели. **Объектно-ориентированное** программирование строится вокруг объектов и их свойств, здесь мы применяем такие термины как Класс, Экземпляр (Объект), Поле (Атрибут), Метод. **Объектно-ориентированное** программирование — наиболее часто используемый подход, хотя существуют задачи ([1](https://www.techtarget.com/searchapparchitecture/definition/reactive-programming), [2](https://docs.confluent.io/platform/current/tutorials/examples/microservices-orders/docs/index.html)), где решение задач описывается лучше в других парадигмах. Подробнее об ООП на примере Python читайте в [статье](https://towardsdatascience.com/python-procedural-or-object-oriented-programming-42c66a008676). На практике мы можем смешивать парадигмы, если это не вредит поддерживаемости кода. Ниже приведен пример решения одной и той же задачи с использованием разных парадигм:

    # PROCEDURAL
    def average_age(table):
        average = 0
        count = 0
        for item in table:
            average = average + item[1]
            count = count + 1
        return average / count
    
    people = [("Ivan", 24), ("Mary", 20), ("Alex", 21), ("Sara", 29)]
    print("Average age:", average_age(people))


    # OOP
    class Person:

        def __init__(self, name, age):
            self.name = name
            self.age = age

    class Workers:

        def __init__(self):
            self.workers = []

        def add(self, worker):
            self.workers.append(worker)

        def get_average_age(self):
            age_sum = 0
            for worker in self.workers:
                age_sum = age_sum + worker.age
            return age_sum / len(self.workers)
    
    workers = Workers()
    workers.add(Person(name="Ivan", age = 24))
    workers.add(Person(name="Mary", age = 20))
    workers.add(Person(name="Alex", age = 21))
    workers.add(Person(name="Sara", age = 29))

    print("Average age:", workers.get_average_age())

Что такое?! Почему в ООП больше кода, когда это такая классная парадигма? Все верно, кода больше, но он лучше структурирован, и нужно думать не о количестве кода, а о том, насколько его легко читать и насколько легко его поддерживать. Например, средний возраст — это характеристика группы людей, поэтому мы пишем метод в `Workers`, а если мы хотим написать метод, который увеличивает возраст в день рождения мы идем в класс `Person`. Так же в **процедурном** программировании часто возникают конструкции типа `item[1]`, и мы должны помнить, что возраст — это индекс 1. В **объектно-ориентированном** мы храним данные другим способом. Т.е. мы работаем не с большой таблицей данных, а структурируем информацию в том виде, с которым принято работать в той или иной сфере. Подумайте, как бы вы решили следующие задачи: 

храним не возраст а дату рождения, нужно по-прежнему знать возраст
хотим уволить :( человека.

### Тестирование 

Оно должно быть. Рассмотрим здесь несколько важных терминов: **Покрытие тестами** (англ. Test Coverage) — доля кода которая покрыта тестами, т.е. та часть кода, которую мы действительно выполняем с использованием тестовых данных. Ниже приведен пример на C++. Код скомпилируется, но при этом его нельзя выполнить без ошибки. Если бы функция `foo` была покрыта тестами, мы бы увидели ошибку сразу.

    #include <iostream>
    
    int main() {
        std::cout << "Hello World!";
        return 0;
    }
    
    float foo(int a) {
        a = 0;
        return 42. / a;
    }

**Разработка через тестирование** (англ. Test-driven development) — подход, при котором мы сначала пишем тесты, а только потом разрабатываем саму функциональность. На практике это не всегда достижимо и не всегда удобно, поэтому в написании тестов после разработки функциональности нет ничего плохого. 

**Юнит-тестирование** (англ. - Unit Testing) - разбиение программы на мелкие блоки, каждый из которых может быть протестирован отдельно. Пример ниже содержит простой класс, который умеет только добавлять 10 и умножать на 10. Мы можем подумать над тестами заранее (**Разработка через тестирование**) или написать тесты потом, в любом случае нам нужно добиться прохождения тестов. На практике вы будете использовать библиотеки типа `unittest`, пример ниже специально написан без использования сторонних библиотек, чтобы показать концепцию тестирования и не отвлекаться на изучение конкретных инструментов, позже в курсе тестированию будут посвящены отдельные занятия.

class Calculator:
    
    def add_10(a):
        return a + 10
    
    def multiply_by_10(a):
        return a * 10
        
if __name__ == "__main__":
    # testing code
    assert Calculator.add_10(12) == 22          #test 1
    print("Pass test 1")
    assert Calculator.multiply_by_10(12) == 120 #test 2
    print("Pass test 2")
    try:                                        #test 3
        Calculator.add_10("asda")
        print("Fail test 3")
    except:
        print("Pass test 3")
    
    try:                                        #test 4
        Calculator.multiply_by_10("asda")
        print("Fail test 4")
    except:
        print("Pass test 4")

*Подумайте почему четвертый тест не прошел и как сделать чтобы он отработал. И оцените насколько удобно иметь тесты*

### Логирование (англ. - Logging)

Ведение журнала событий, в котором записывается информация, которая облегчает отслеживание событий, которые нельзя отнести к нормальной работе кода или системы в целом.

### Язык разметки (англ. - Markup Language)

**Язык разметки** позволяет снабдить текст специальными символами, которые регулирует его отображение. Например, этот документ написан с помощью языка разметки *Markdown*, а GitHub или Gitlab собрал из него красивый документ, который вы сейчас и читаете. Популярность *Markdown* породила [множество](https://habr.com/ru/post/672266/) инструментов написания текста в нем и компиляции итогового документа. Данный раздел выглядит вот так (редактор ReText):

![markdown_source](./img/markdown_source.png)

### Приложение (англ. - application)

По английски это Application или что используется app. Последнее часто используется в при написании приложений. Например при написании **бэкэнда**, используется именно это имя для того, чтобы обозначить главное приложение.

    from fastapi import FastAPI
    
    app = FastAPI()
    
    @app.get("/")
    async def root():
        return {"message": "Hello World"}


### Ошибка (англ. - bug)

Ошибка или непонятное поведение программы, в общем все что нельзя отнести к нормальному поведению программы. Часто используется прямое произношение с английского **баг**. Баг может вызвать ошибку, при использовании определенного места в программе и это хороший сценарий поскольку, сразу понятно где происходит ошибка. *В примере ниже в print_value() идет обращение к переменной, которую ранее нигде не инициализировали, можно исправить написва `self.value` вместо `value`*

    class ClassWithBugFailFast:

        def print_value(self):
            print(value)

        def set_value(self, value):
            self.value = value

    if __name__ == "__main__":
        cls = ClassWithBugFailFast()
        cls.set_value(123)
        cls.print_value()


Часто бывает, что ошибки не происходит, но поведение программы не очевидно.

    class ClassWithBugNoFail:

        def print_value(self, value):
            print(self.value)

        def set_value(self, value):
            self.value = value

    if __name__ == "__main__":
        cls = ClassWithBugNoFail()
        cls.set_value(123)
        cls.print_value(456)



### Fail-fast

В примере выше мы посмотрели что неправильно написанный код, который сразу приводит к ошибке лучше чем, код который не приводит к ошибке, но приводит к непонятным результатам. Понятно что мы не планируем писать баги, но поведение, при котором мы вызываем ошибку (кидаем исключение) при непонятной ситуации, получило название **fail-fast**. Подход **fail fast** является предпочтительным при написании кода, так как позволяет определить место где произошла ошибка. Другим подходом при обработке непредвиденной ситуации является подхода **forgive**, при котором мы пытаемся уменьшить негативные последствия и стараемся не кидать ошибки. Подробнее про два подхода можно почитать в [статье](https://habr.com/ru/post/218325/)

### Исключение (англ. - Exceptions)

Исключительная ситуация требует исключительных мер. При работе приложения мы стараемся предусмотреть возможные варианты его использования, например варианты входных данных, которые приходят в приложение от пользователя. Мы можем попробовать исправить это. Например конвертировать строке содержащую число к целому числе, используя `int()`, а если не получится то `float()`. *Для данного примера считаем что это приемлемый вариант*. 

    class Validator:
        
        def get_int_number(string):
            result = 0
            try:
                result = int(string)
            except ValueError:
                print('Could convert to int, try via float:')
                result = int(float(string))
            return result
            
    if __name__ == "__main__":
        print(Validator.get_int_number('10.'))
        try:
            user_input = 'aaa'
            Validator.get_int_number(user_input)
        except ValueError:
            print(f'{user_input} is not a number, please enter proper data')
        except Exception as e:
            print(f'Unknow error ask developers {e}')

Если не получается конвертировать в число в принципе, как в случае со строкой `'aaa'`, мы можем попросить пользователя повторить ввод. Если же в происходит что-то, что мы не можем идентифицировать, то тоже должны "поймать" это на верхнем уровне, в примере выше это `except Exception as e`, и зафиксировать это, можно например записать сообщение об ошибке в лог.






